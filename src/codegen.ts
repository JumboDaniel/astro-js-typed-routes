import type { AstroConfig } from "astro";
import { writeFileSync, mkdirSync } from "node:fs";
import { fileURLToPath } from "node:url";
import { dirname } from "node:path";
import { scanPages, type PageNode } from "./scan.js";
import { extractParams } from "./utils.js";

/**
 * Entry point for code generation. Scans `src/pages/`, builds the
 * `declare module` type overrides and `ROUTES` runtime object, then
 * writes `src/typed-routes.d.ts` and `src/routes.gen.ts` to the user's project.
 *
 * Called from the Astro integration hooks:
 * - `astro:config:done` (initial generation)
 * - `astro:server:setup` (on file add/unlink in dev)
 * - `astro:build:start` (production build)
 */
export function generateRoutes(config: AstroConfig): void {
  const pagesDir = fileURLToPath(new URL("pages/", config.srcDir));
  const dtsPath = fileURLToPath(new URL("typed-routes.d.ts", config.srcDir));
  const routesPath = fileURLToPath(new URL("routes.gen.ts", config.srcDir));

  const pages = scanPages(pagesDir);

  // Generate the declare module .d.ts file
  const dtsOutput = buildDeclarationFile(pages);
  mkdirSync(dirname(dtsPath), { recursive: true });
  writeFileSync(dtsPath, dtsOutput, "utf-8");

  // Generate the ROUTES runtime object (always flat — locale prefixing is handled by $path())
  const routesOutput = buildRoutesFile(pages);
  writeFileSync(routesPath, routesOutput, "utf-8");

  console.log(`[astro-typed-routes] generated (${pages.length} routes)`);
}

// ─── Declaration File (.d.ts) ─────────────────────────────────────
//
/**
 * Builds the `declare module` .d.ts file that overrides the loose
 * source types with project-specific typed versions.
 */
function buildDeclarationFile(pages: PageNode[]): string {
  const routeRows = pages.map((p) => {
    const params = p.params.length === 0 ? "null" : JSON.stringify(p.params);
    return `    "${p.routePath}": { params: ${params} };`;
  });

  return `// Auto-generated by astro-typed-routes. Do not edit.

declare module "astro-typed-routes/path" {
  export type Routes = {
${routeRows.join("\n")}
  };

  export type RouteId = keyof Routes;

  export type ParamsRecord<T extends RouteId> =
    Routes[T]["params"] extends Array<string>
      ? { [K in Routes[T]["params"][number]]: string }
      : never;

  export type RouteOptions<T extends RouteId> = {
    to: T;
    locale?: string;
    search?: Record<string, string>;
    hash?: string;
  } & (Routes[T]["params"] extends null
    ? { params?: never }
    : { params: ParamsRecord<T> });

  export function $path<T extends RouteId>(args: RouteOptions<T>): string;
}

declare module "astro-typed-routes/create-route" {
  import type { AstroGlobal, GetStaticPaths } from "astro";
  import type { RouteId, RouteOptions, ParamsRecord } from "astro-typed-routes/path";

  type AstroAny = AstroGlobal<any, any, any>;

  export function createRoute<T extends RouteId>(opts: { routeId: T }): {
    getParams: (astro: AstroAny) => Routes[T]["params"] extends null ? never : ParamsRecord<T>;
    getProps: <P>(astro: AstroAny) => P;
    redirect: <L extends RouteId>(astro: AstroAny, link: RouteOptions<L>) => Response;
    rewrite: <L extends RouteId>(astro: AstroAny, link: RouteOptions<L>) => Promise<Response>;
    createGetStaticPaths: (fn: GetStaticPaths) => GetStaticPaths;
  };
}

declare module "astro-typed-routes/link" {
  import type { HTMLAttributes } from "astro/types";
  import type { RouteOptions, RouteId } from "astro-typed-routes/path";

  type LinkBase = Omit<HTMLAttributes<"a">, "href">;
  type ExternalProps = LinkBase & { external: true; href: string; to?: never };
  type InternalProps<T extends RouteId> = LinkBase &
    RouteOptions<T> & { external?: false; href?: never };

  export type Props<T extends RouteId> = ExternalProps | InternalProps<T>;
  export default function Link<T extends RouteId>(props: Props<T>): any;
}

declare module "astro-typed-routes/link-react" {
  import type { ComponentProps } from "react";
  import type { RouteOptions, RouteId } from "astro-typed-routes/path";

  type LinkBase = Omit<ComponentProps<"a">, "href">;
  type ExternalProps = LinkBase & { external: true; href: string; to?: never };
  type InternalProps<T extends RouteId> = LinkBase &
    RouteOptions<T> & { external?: false; href?: never };

  export type ReactLinkProps<T extends RouteId> = ExternalProps | InternalProps<T>;
  export default function Link<T extends RouteId>(props: ReactLinkProps<T>): any;
}
`;
}

// ─── ROUTES Runtime Object ────────────────────────────────────────

/**
 * Generates the `routes.gen.ts` file containing the `ROUTES` runtime object.
 *
 * The ROUTES object is always flat — locale prefixing is NOT baked in.
 * Use `$path({ href: "/test", locale: "fr" })` to add locale prefixes at runtime.
 */
function buildRoutesFile(pages: PageNode[]): string {
  return [
    header(),
    `export const ROUTES = {`,
    buildRouteObject(pages, ""),
    `} as const;`,
    "",
  ].join("\n");
}

// ─── Shared Helpers ───────────────────────────────────────────────

/** Internal tree structure for converting flat routes to nested objects. */
type TreeNode = {
  routePath: string;
  params: string[];
  children: Map<string, TreeNode>;
};

function buildRouteObject(
  pages: PageNode[],
  prefix: string,
  indent = "  ",
): string {
  const tree = buildTree(pages);
  return renderTree(tree, prefix, indent, pages);
}

function buildTree(pages: PageNode[]): Map<string, TreeNode> {
  const root = new Map<string, TreeNode>();

  for (const page of pages) {
    const segments =
      page.routePath === "/" ? [] : page.routePath.slice(1).split("/");

    let current = root;

    for (let i = 0; i < segments.length; i++) {
      const seg = segments[i];
      if (!current.has(seg)) {
        current.set(seg, {
          routePath: "/" + segments.slice(0, i + 1).join("/"),
          params: extractParams("/" + segments.slice(0, i + 1).join("/")),
          children: new Map(),
        });
      }
      current = current.get(seg)!.children;
    }

    if (segments.length === 0 && !root.has("__index")) {
      root.set("__index", {
        routePath: "/",
        params: [],
        children: new Map(),
      });
    }
  }

  return root;
}

function renderTree(
  tree: Map<string, TreeNode>,
  prefix: string,
  indent: string,
  pages: PageNode[],
): string {
  const lines: string[] = [];

  for (const [key, node] of tree) {
    const hasChildren = node.children.size > 0;

    if (key === "index") continue;

    if (!hasChildren) {
      lines.push(`${indent}"${key}": ${buildRouteFunction(node, prefix)},`);
      continue;
    }

    lines.push(`${indent}"${key}": {`);

    const isRealRoute = pages.some((p) => p.routePath === node.routePath);
    if (isRealRoute) {
      lines.push(`${indent}  "index": ${buildRouteFunction(node, prefix)},`);
    }

    lines.push(renderTree(node.children, prefix, indent + "  ", pages));

    lines.push(`${indent}},`);
  }

  return lines.join("\n");
}

function buildRouteFunction(node: TreeNode, prefix: string): string {
  if (node.params.length === 0) {
    return `() => "${prefix}${node.routePath}"`;
  }

  const paramType = node.params.map((p) => `${p}: string`).join(", ");

  let path = `${prefix}${node.routePath}`;
  for (const param of node.params) {
    path = path.replace(`[${param}]`, `\${p.${param}}`);
  }

  return `(p: { ${paramType} }) => \`${path}\``;
}

function header(): string {
  return [
    `// Auto-generated by astro-typed-routes. Do not edit.`,
    `// Re-run dev server or build to regenerate.`,
    "",
  ].join("\n");
}
